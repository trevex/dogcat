package server

import (
	"context"
	"io"
	"net/http"
	"net/http/httputil"
	"net/url"
	"time"

	"github.com/NucleusEngineering/dogcat/chapter02b/ent"
	"github.com/NucleusEngineering/dogcat/chapter02b/web"

	"github.com/gin-contrib/gzip"
	"github.com/gin-contrib/logger"
	limits "github.com/gin-contrib/size"
	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
)

func NewServerCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:           "server [flags] [config-file]",
		Short:         "Starts the Webserver and GraphQL API",
		SilenceErrors: true,
	}

	var (
		isDev   bool
		dialect string
		connStr string
	)

	flags := cmd.Flags()
	flags.BoolVar(&isDev, "dev", false, "Ignores settings and starts with in-memory database")
	// TODO: driver/dialect and connStr flags

	cmd.RunE = func(cmd *cobra.Command, args []string) error {
		ctx := cmd.Context()
		// Make sure to use release-mode
		gin.SetMode(gin.ReleaseMode)
		zerolog.SetGlobalLevel(zerolog.InfoLevel)

		// Root at the `dist` folder generated by the Next.js app.
		webFS, err := web.FS()
		if err != nil {
			return err
		}
		fileServer := http.FileServer(http.FS(webFS))

		if isDev { // Ok, we want to start the development setup
			gin.SetMode(gin.DebugMode) // Start gin in debug mode and increase log-level
			zerolog.SetGlobalLevel(zerolog.DebugLevel)

			// Let's use SQLite
			dialect = ent.SQLite
			connStr = ent.SQLLiteInMemoryConnStr

			// Instead of the file-server we want to proxy to frontend dev-server
			remote, _ := url.Parse("http://localhost:3000")
			handler := func(p *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) {
				return func(w http.ResponseWriter, r *http.Request) {
					r.Host = remote.Host
					log.Info().Msg("WTF")
					p.ServeHTTP(w, r)
				}
			}
			proxy := httputil.NewSingleHostReverseProxy(remote)
			fileServer = http.HandlerFunc(handler(proxy))
		}

		// Open database connection
		e, err := ent.Open(ctx, dialect, connStr)
		if err != nil {
			return err
		}

		r := gin.New()
		r.Use(gin.Recovery())
		r.Use(gzip.Gzip(gzip.DefaultCompression))
		r.Use(limits.RequestSizeLimiter(2 * 1024 * 1024))
		r.Use(logger.SetLogger(logger.WithLogger(func(c *gin.Context, out io.Writer, latency time.Duration) zerolog.Logger {
			return zerolog.New(out).With().
				Dict("request", zerolog.Dict().
					Str("ip", c.ClientIP()).
					Str("path", c.Request.URL.Path).
					Str("method", c.Request.Method).
					Str("agent", c.Request.UserAgent())).
				Dict("response", zerolog.Dict().
					Int("code", c.Writer.Status()).
					Dur("latency", latency).
					Int("length", int(c.Writer.Size()))).
				Logger()
		})))

		// We add our fileServer (not using r.StaticFS to make it easy to drop in proxy)
		r.NoRoute(gin.WrapH(fileServer))
		// Let's also add our API (see api.go for details)
		AddAPIRoutes(e, r)

		// Start HTTP server at :4000.
		log.Info().Msg("Starting HTTP server on http://localhost:4000...")
		srv := &http.Server{
			Addr:    ":4000",
			Handler: r,
		}
		go func() {
			if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Error().Err(err).Msg("error listening on server")
			}
		}()

		<-ctx.Done()
		ctxShutdown, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		if err := srv.Shutdown(ctxShutdown); err != nil {
			log.Error().Err(err).Msg("error shutting down server")
			return err
		}
		return nil
	}

	return cmd
}
