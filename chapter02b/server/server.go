package server

import (
	"net/http"
	"net/http/httputil"
	"net/url"

	"github.com/NucleusEngineering/dogcat/chapter02b/ent"
	"github.com/NucleusEngineering/dogcat/chapter02b/web"

	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
)

func NewServerCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:           "server [flags] [config-file]",
		Short:         "Starts the Webserver and GraphQL API",
		SilenceErrors: true,
	}

	var (
		isDev   bool
		dialect string
		connStr string
	)

	flags := cmd.Flags()
	flags.BoolVar(&isDev, "dev", false, "Ignores settings and starts with in-memory database")
	// TODO: driver/dialect and connStr flags

	cmd.RunE = func(cmd *cobra.Command, args []string) error {
		ctx := cmd.Context()

		// Root at the `dist` folder generated by the Next.js app.
		webFS, err := web.FS()
		if err != nil {
			return err
		}
		fileServer := http.FileServer(http.FS(webFS))

		if isDev { // Ok, we want to start the development setup
			dialect = ent.SQLite
			connStr = ent.SQLLiteInMemoryConnStr

			// Instead of the file-server we want to proxy to frontend dev-server
			remote, _ := url.Parse("http://localhost:3000")
			handler := func(p *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) {
				return func(w http.ResponseWriter, r *http.Request) {
					r.Host = remote.Host
					p.ServeHTTP(w, r)
				}
			}
			proxy := httputil.NewSingleHostReverseProxy(remote)
			fileServer = http.HandlerFunc(handler(proxy))
		}

		// Open database connection
		_, err = ent.Open(ctx, dialect, connStr)
		if err != nil {
			return err
		}

		// The static Next.js app will be served under `/`.
		http.Handle("/", fileServer)

		// Start HTTP server at :4000.
		log.Info().Msg("Starting HTTP server on http://localhost:4000...")
		return http.ListenAndServe(":4000", nil)
	}

	return cmd
}

